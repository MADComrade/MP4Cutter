///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//---------------------------ПОДКЛЮЧЕНИЕ ЗАГОЛОВОЧНЫХ ФАЙЛОВ---------------------------------------------------------//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "tkhd.h"
#include <iomanip>

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//---------------------------ОПРЕДЕЛЕНИЕ МЕТОДОВ---------------------------------------------------------------------//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//*******************************************************************************************************************//
//-------------------------------------------------------------------------------------------------------------------//
//---------------------------КЛАСС АТОМА TKHD------------------------------------------------------------------------//
//-------------------------------------------------------------------------------------------------------------------//
//*******************************************************************************************************************//

//*******************************************************************************************************************//
//------------конструктор--------------------------------------------------------------------------------------------//
TKHD::TKHD():Atom(TKHD_NAME, TKHD_DIG_NAME)
{
    m_data.resize(60,0);
}

//*******************************************************************************************************************//
//------------деконструктор------------------------------------------------------------------------------------------//
TKHD::~TKHD()
{

}

//*******************************************************************************************************************//
//------------парсинг атома TKHD-------------------------------------------------------------------------------------//
void TKHD::parse(StreamReader &stream, uint32_t &startPos)
{
    printAtomName(LV3);                                                                                              //вывод названия атома с определненным выравниванием(lv)
    uint32_t pos = startPos;                                                                                         //присваивание переменной pos значения текущей начальной позиции в файле startPos
    stream.setPos(pos);                                                                                              //установка указателя файла на новую позицию pos
    m_size = stream.readSizeAtom();                                                                                  //размер чанка атома в памяти(???)
    pos+=OFFSET_TITLE;                                                                                               //увеличение значения pos на 8 байт (размер и заголовок атома)
    stream.setPos(pos);                                                                                              //установка указателя файла на новую позицию pos
    m_verFlag = stream.readUInt32();                                                                                 //считываются в m_verFlag 4 байта после размера и заголовка атома
    m_creationTime = stream.readUInt32();                                                                            //в m_creationTime считываются следующие 4 байта после уже прочитанных в m_verFlag (считываются следующие 4 байта автоматически, потому что здесь не написано функций для перевода указателя в определенную позицию setPos(pos), и получается, что указатель сам смещается вместе с прочитанными 4-мя байтами)
    m_modificationTime = stream.readUInt32();                                                                        //считывается следующая порция 4-х байт в m_modificationTime
    m_trackID = stream.readBigEndianUInt32();                                                                        //считываются следующие 4 байта в переменную m_trackID в формате BigEndian
    stream.readBigEndianUInt32();                                                                                    //просто считываются еще следующие 4 байта (и указатель вместе с ними, как и в предыдущих считываниях байтов)
    m_duration = stream.readBigEndianUInt32();                                                                       //считываются следующие 4 байта в переменную m_duration в формате BigEndian
    stream.read(&(m_data[0]),m_data.size());                                                                         //чтение m_data.size байт из файла m_file и их размещение по адресу, начиная с m_data[0] и т.д.
    startPos += m_size;                                                                                              //значение начальной позиции startPos увеличиваем на размер чанка атома m_size
}

//*******************************************************************************************************************//
//------------установка новой длительности видео---------------------------------------------------------------------//
void TKHD::setNewDuration(uint32_t time)
{
    m_duration = time * m_singletonSettings.getTimeScaleVideo();                                                     //для универсальности передавать time scale
}

//*******************************************************************************************************************//
//------------запись атома TKHD--------------------------------------------------------------------------------------//
void TKHD::writeAtom(StreamWriter &stream)
{
    stream.writeLitToBigEndian(m_size);                                                                              //запись размера в новый файл MP4 в BigEndian
    stream.writeAtomName(TKHD_NAME);                                                                                 //запись имени атома TKHD
    stream.writeUInt32(m_verFlag);                                                                                   //запись значения m_verFlag
    stream.writeUInt32(m_creationTime);                                                                              //запись времени создания
    stream.writeUInt32(m_modificationTime);                                                                          //запись времени изменения
    stream.writeLitToBigEndian(m_trackID);                                                                           //запись значения m_trackID в BigEndian
    stream.writeLitToBigEndian(m_reserved);                                                                          //запись значения m_reserved в BigEndian
    stream.writeLitToBigEndian(m_duration);                                                                          //запись значения m_duration в BigEndian
    stream.write(&(m_data[0]),m_data.size());                                                                        //запись в новый файл MP4 данных длиной m_data.size() по адресу m_data[ 0 ]
}
